% Created 2020-08-13 Thu 23:02
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\setlength{\parindent}{1em}
\setlength{\parskip}{0.5em}
\usepackage[citestyle=alphabetic,bibstyle=alphabetic, hyperref=true, backref=true,maxcitenames=3,url=true,backend=biber,natbib=true] {biblatex}
\addbibresource{bibliography.bib}
\usepackage[a4paper, total={7in, 9in}]{geometry}
\usepackage[ruled, procnumbered]{algorithm2e}
\SetArgSty{}
\usepackage[dvipsnames]{xcolor}
\usepackage{amssymb}
\usepackage{pifont}
\newcommand{\cmark}{\color{ForestGreen}\ding{52}}%
\newcommand{\xmark}{\color{Maroon}\ding{55}}%
\hypersetup{colorlinks=true}
\renewcommand{\sectionautorefname}{{\color{Black}\S}}
\renewcommand{\subsectionautorefname}{{\color{Black}\S\S}}
\renewcommand{\subsubsectionautorefname}{{\color{Black}\S\S\S}}
\renewcommand{\functionautorefname}{{\color{Black}\textbf{Function}}\color{Magenta}}
\renewcommand{\algorithmautorefname}{{\color{Black}\textbf{Algorithm}}\color{Magenta}}
\usepackage{subcaption}
\usepackage[shortlabels]{enumitem}
\usepackage{newfloat}
\DeclareFloatingEnvironment[fileext=lol, listname={List of L-system definitions}, name=L-system, placement=tbhp, within=section]{lsystem}
\usepackage{wrapfig}
\usepackage{todonotes}
\usepackage{pifont,kantlipsum}
\newcommand*{\altasterism}{\vspace*{1em plus .5em minus .5em}\noindent\hspace*{\fill}\ding{104}\hspace*{\fill}}
\usepackage{rugscriptie}
\supervisor{dr. J. Kosinka}
\supervisor{G. J. Hettinga}
\date{August 2020}
\faculty{fwn} % Or feb, fgg, fgmw, fl, frg, frw, fw, umcg
\thesistype{Bachelors's thesis} % Will be printed unmodified
\author{Wiebe-Marten Wijnja}
\date{\today}
\title{\Huge In by Out again\\\medskip
\large Faking arbitrarily-deep zooming on Iterated Function Systems}
\hypersetup{
 pdfauthor={Wiebe-Marten Wijnja},
 pdftitle={\Huge In by Out again},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.3.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\pagebreak
\setcounter{tocdepth}{3}
\tableofcontents

\section{Abstract}
\label{sec:org62e804a}

\section{Introduction}
\label{sec:org0f916c5}

Iterated Function Systems (IFSs) are a method to generate infinitely detailed fractal images 
by repeatedly applying simple mathematical functions until a fixed point is reached. [CITE]
IFSs see use in rendering/modeling of physical phenomena[CITE], image compression [CITE] and representing gene structures [CITE].
Sometimes they also see use simply for the aesthetic beauty of their graphical representations[CITE].

Various computer algorithms to visualize IFSs exist [CITE], [CITE].
However, these all take either a still image as final result, or, if they want to render an animation,
view this as a sequence of separate still images to generate.

This leaves a door open for potential optimization: if there is information that remains the same between animation frames, 
then we could compute it only once and re-use this information for all frames.

For instance, many kinds of animations consist of transformations of the camera viewport w.r.t the viewed fractal over time like translation, rotation and scaling do not require alterations to the fractal itself.
This means that (an approximation of) the fractal might be computed once and then be used for all frames.

Furthermore, because of the self-similar nature of the rendered fractals,
it might it be possible to simulate zooming in to an arbitrary depth by 'jumping up' to a more shallow viewport
that shares the same self-similarity as the original one. 

Investigating this claim in detail is the essence of this thesis.

\subsection{Overview}
\label{sec:orgbcbd99d}


\section{Background}
\label{sec:orgca3ba16}
\label{section:background}

Informally, an Iterated Function System is a set of transformations that, given any input image, can create a new image by

\begin{enumerate}
\item transforming the input image with each of the transformations
\item combining all transformed images together. This is the new image.
\end{enumerate}

This process is then repeated an arbitrary number of times, until changes between the input image and output image are no longer visible to the human eye.

What you end up with is a visual representation of the IFS's attractor.

\todo[inline]{reference picture}


\subsection{Formal definition of an Iterated Function System}
\label{sec:orgc57e3e1}

Formally, an Iterated Function System consists of a finite set of contraction mappings that map a complete metric space \((\mathcal{M}, d)\) to itself:

$$ = \{ f_i : \mathcal{M} \rightarrow \mathcal{M} | i = 1, 2, \ldots, N \}, N \in \mathbb{N}$$

That each mapping needs to be contractive means that for each mapping \(f_i\), the distance between every two arbitrary points \(a\) and \(b\) in \((\mathcal{M}, d)\) needs to be larger than the distance of the points after transforming them:

$$d(f_i(a), f_i(b)) < d(a, b)$$

We can then take the union of performing all of these mappings on any compact set of points \(\mathcal{S}_0 \subset \mathcal{M}\). This procedure is called the \emph{Hutchkinson Operator} (\(H\)). 
We can iterate it as often as we'd like:

$$ \mathcal{S}_{n + 1} = H(\mathcal{S}_n) = \bigcup_{i=1}^{N} f_i(\mathcal{S}_n) $$

If we perform this operation an arbitrary number of times, we approach the fixed-point or attractor, \(\mathcal{A}\), of the Iterated Function System:

$$\mathcal{A} = \lim_{n \rightarrow \infty} \mathcal{S}_n$$

Curiously, which set of points \(\mathcal{S}_0\) we started with makes no difference (we might even start with a single point) [CITE].

\altasterism

Most research of IFSs restricts itself to using \(\mathbb{R}^2\) as metric space\footnote{More formally, the two-dimensional Euclidean space: \(\left(\mathbb{R}^2, d(p, q) = \sqrt{p - q)^2}\right)\).} which can easily be rendered to screen or paper,
and furthermore most commonly-used IFSs are restricted to use \emph{affine transformations} as mappings.

Because of their prevalence, these are also the restrictions that will be used in this thesis.

\subsection{Rendering an Iterated Function System}
\label{sec:org42f9761}

A couple of algoritms exist to render (visualize) the attarctor of an Iterated Function System. 
While it is impossible to render the attractor exactly, as this would require an infinite number of transformation steps,
we can approximate it until we are certain that the difference between our approximation and the attractor is smaller than
the smallest thing we can visually represent (e.g. smaller than the size of a pixel).

Because we apply \(H\) many times and each time consists of taking the union of \(N\) different transformations,
the result can be seen as traversing an (infinitely deep) tree of transformations, 
where each sub-tree is self-similar to the tree as a whole.

Different algorithms take different approaches to evaluating this tree (up to a chosen finite depth).

More in-depth information about the rendering of Iterated Function Systems can be found [CITE]. 
Short summaries of the two most common techniques will now follow.

\todo[inline]{PICTURE OF THIS TREE}


\subsubsection{The deterministic method}
\label{sec:org98711ed}

In this approach we evaluate the whole tree up to a chosen depth. The algorithm works as follows:

\begin{enumerate}
\item Pick a starting point \(z_0\);
\item Traverse the tree down to the chosen depth \(k\), building up a sequence of transformations \footnote{\(\circ\) stands for function composition: \((f \circ g)(x) = f(g(x))\). 
Be aware that when affine transformation functions are represented as matrices (e.g. \(F\) and \(G\)), matrix multiplication is in the opposite order (\(f \circ g \equiv G \cdot F\))}
\(f_{i_k} \circ \ldots \circ f_{i_1}\);
\item For each node at this depth, evaluate and render \(z_k = (f_{i_k} \circ \ldots \circ f_{i_1})(z_0) = f_{i_k-1}(z_{k-1})\);
\end{enumerate}

Since \(z_{k} = f_{i_k-1}(z_{k-1})\) this procedure takes, for an approximation that consists of \(N\) points, depending on the tree traversal chosen:

\begin{itemize}
\item a linear amount ( \(\mathcal{O}(N)\) ) of memory  for a breadth-first tree-traversal.
\item a logarithmic amount ( \(\mathcal{O}(\log{N})\) ) of memory for a depth-first tree-traversal.
\end{itemize}

The advantage of the breadth-first traversal is that generation could be stopped interactively,
while the depth-first traversal requires the stopping criterion to be known beforehand. [CITE]

While the deterministic method is easy to understand (and indeed is a direct translation of the informal process described at the start of \autoref{section:background}),
it is usually less efficient and more complex to implement on a computer than the algorithm that will be described next.

\subsubsection{The chaos game}
\label{sec:org558725b}
\label{subsection:chaos_game}

The \emph{stochastic method}[CITE], also known as the \emph{random iteration algorithm}[CITE] or more frequently the \emph{chaos game}, works as seen in \autoref{chaosGame}

\begin{algorithm}[H]
\caption{the chaos game}
\label{chaosGame}
  $n$: the number of transformations the IFS consists of. \\
  $z$: a random point on the screen  \\
  \While{less than $N$ points plotted}{ 
    $i$: a random integer between $0$ and $n$.  \\
    $z = f_i(z)$  \\
    render($z$) except during the first $x$ iterations \\
  }

\end{algorithm}

This method converges to a correct result because of the following two facts:

\begin{itemize}
\item because the precision of the canvas we render on is finite, and because all transformations are contracting,
two points \(a\) and \(b\) are indistinguishable after only \(x\) transformations.
 In other words, only the latest \(x\) transformations determine at what location on the canvas a point will end up (with the latest transformation having the largest effect on the point's final location).\footnote{Methods for precisely determining the lower and upper bounds of IFS contraction for a particular IFS (and therefore the exact value of \(x\)) exist [CITE], 
but are not relevant for this thesis.}
\item at each depth in the tree the subtree remains the same, so every sequence of transformations approaches the attractor.
\end{itemize}

Therefore, all intermediate points after the first \(x\) iterations are visually indistinguishable from the a point that is part of the attractor.
By running this non-deterministic approach for enough iterations we approach a diverse enough set of 'transformation sequences of length \(x\)' that we end up covering the whole attractor.

The nice thing about the chaos game is that it does not require any extra memory (besides the point \(z\)).
Also, because it is so simple and little auxiliary memory is needed, it runs very efficiently on modern CPU architectures.

A disadvantage of the chaos game is that the result is by its very nature \emph{non-deterministic}.
If not enough points are used, the result might end up 'grainy' and it is not predictable what part of the attractor will be covered.

One further disadvantage the chaos game has, is that in its simplest form, all transformations have an equally likely chance to be used.
However, because some transformations might be (much) more contracting than others, this means that coverage of the attractor is not even,
which means that we need to use much more iterations than would be the case if we balance it out.

Therefore, most implementations of the chaos game allow (or require) the user to specify a \emph{probability} for each transformation.
All these probabilities together ought to sum up to 1.\footnote{These probabilities are often fine-tuned by hand, although algorithms to determine balanced probabilities exist as well [CITE] section 2.4.}

\altasterism

Because of its simplicity and efficiency, the chaos game is used more frequently than the deterministic method for practical implementations.
The chaos game is also easier to paralellize for Graphical Processor Units (GPUs), as will be outlined in the next subsection.

\subsection{IFS rendering on a GPU}
\label{sec:orgbdd27a1}

It is enticing to port IFS rendering to run on GPU-architecture because to produce a smooth image, often hundreds of millions of points are needed.

However, optimizing IFS rendering to run well on GPU-architectures is a bit of a challenge.

GPU shaders usually operate by running a check for every pixel on the final canvas, to determine its color.
For other fractals like the Mandelbrot- and Julia-sets, this is a natural fit since the construction of those fractals works exactly in that way.

For an IFS this does not work, as an IFS is created in the other direction. Points end up at some location on the canvas \emph{only after transforming} many times.
Attempts to go the other way fall flat, for instance because this would require to invert the IFS' mappings, but they are not guaranteed to be invertible.

Instead, General-Purpose GPU-techniques are used that are able to use the top-down approach.

\subsubsection{the chaos game on the GPU}
\label{sec:org7fd41b9}
\label{subsection:chaos_game_gpu}

The deterministic method is difficult to paralellize on the GPU because of the extra memory that is required to keep track of the current position in the tree.
Coordinating which GPU thread would calculate which part of the tree and sharing results would be a hassle.

Instead, the chaos game is more frequently used because of its simplicity. It is paralellized in a straightforward way, by running the iteration process many times side-by-side (one per GPU thread),
and then combine the final results of all of these on a single canvas. [CITE]

\subsubsection{the deterministic method on the GPU}
\label{sec:org86a92c4}

An exciting approach taken in [CITE] uses the deterministic method instead:
by using the fast inverse square root operation, even unbounded (noncontracting) and nonlinear IFSs can be efficiently
evaluated using the deterministic method, programmed in normal GPU shaders that manipulate a couple of GPU textures.




\section{Problem Description}
\label{sec:org45f035b}

In the last section, the construction of an IFS's attractor was formally defined, 
and different approaches of rendering it were outlined.

While many different approaches to IFS rendering exist, some of them quite efficient,
none of them re-uses information from rendering one image of the IFS for rendering another.

This leads us to the research question of this thesis:

\textbf{\textbf{Is it possible, by re-using information between animation frames, to render animations of an Iterated Function System's attractor in which the camera zooms in, in real-time?}}

\section{Approach}
\label{sec:orgb622a54}

To put this to the test, a simple software program was created which calculates the IFS' attractor only once,
and then allows a user to interactively zoom and pan the camera around to investigate different parts of the attractor.

\subsection{Design}
\label{sec:org5277319}

The main inspiration for the re-usability approach is that we can modify the GPU-variant of the chaos game algorithm outlined in \autoref{subsection:chaos_game_gpu}
to render to a \emph{point cloud} instead of immediately to a canvas.
When we then move around the camera, we are able to re-use the points in the point cloud;
only where the points in the point cloud end up on screen exactly needs to be re-calculated, 
by transforming all of the points exactly once with the 'view transformation' 
(and culling all points outside of the viewport).

This is faster than re-evaluating the whole attractor using the chaos game at every frame which would require transforming all points \emph{many} times.

Formally, running the whole chaos game takes \((2(N+x))\) transformations to render \(N\) points. \footnote{Using the definitions of \autoref{subsection:chaos_game}: \(N\) is the total number of points we want to render in our attractor approximation, 
and \(x\) is the minimum number of transformations we need to apply to any arbitrary point to make it visually indistinguishable from a point exactly on the attractor.}

Unoptimized, it takes \(N\) transformations to render a precomputed point cloud to screen. 
This does not seem very impressive since \(\mathcal{O}(2(N+x)) \approx \mathcal{O}(2N) \approx \mathcal{O}(N)\),
placing the two approaches in the same order of efficiency.

However, it is possible to optimize point cloud-based rendering using the techniques outlined in the next section
to run in \(\mathcal{O}(\log{N})\) instead, which is a big improvement.


\subsubsection{Potential point cloud-based optimizations}
\label{sec:org1f1a548}

The generation and rendering of point clouds is a quite well-understood problem[CITE]. point clouds see widespread use,
most commonly in 3D-graphics that originates from a '3D scanner' .

point clouds can be rendered in a reasonably efficient manner by storing them in a 'Bounding Volume Hierarchy',
for instance in a binary search tree that is ordered using the Morton space filling curve. [CITE]
Storing the points of a point cloud in this way allows us to efficiently cull most uninteresting points (i.e. points that would end up outside of the current camera viewport),
which speeds up the rendering procedure tremendously.

However, while this problem is well-understood, the implementation is not trivial at all [CITE].
As such, the program developed for this thesis does not implement these techniques.
Instead, the choice was made for simplicity, 
and the use of a bounded volume hierarchy is treated as a potential future optimization.

\subsubsection{Simplicity}
\label{sec:org3924fb2}

As already mentioned in the previous subsection, the decision was made to keep the program as simple as possible. 
This allows a qualitative (human) measurement
of whether the technique of using point clouds as intermediate re-usable information is at all feasible.

It can thus be considered a first step in answering the research question.

\subsection{Implementation}
\label{sec:orge256af4}

\section{Findings}
\label{sec:org365db71}


\section{Discussion}
\label{sec:org41d4fed}

\section{Conclusion}
\label{sec:orgafa8544}

\section{Further Work}
\label{sec:org646e738}
\end{document}