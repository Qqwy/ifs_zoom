-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package IFSZoom
@version 0.1.0.0


-- | A one-function module that exposes a left-to-right function
--   application operator.
module Pipe

-- | left-to-right application of a function to a value. ``` (x |&gt; f) =
--   (f x) ```
--   
--   This is similar to Data.Function.&amp; but more readable. It is based
--   on the same syntax that exists in e.g. F#, Elm, Elixir.
(|>) :: a -> (a -> b) -> b
infixl 1 |>


-- | This module allows you to transform a (Word32, Word32) <a>-</a> Word64
--   on the GPU. It is a building block of a parallel algorithm that works
--   with morton encoding/decoding.
module Lib.MortonCode
pointToMorton :: Exp (Float, Float) -> Exp MortonCode
mortonToPoint :: Exp MortonCode -> Exp (Float, Float)

-- | Returns the morton-code interleaving
--   
--   where from MSB to LSB we have one bit of y and then of x (and then the
--   next-highest bit of y and then the next-highest bit of x etc).
interleaveBits :: Exp Word32 -> Exp Word32 -> Exp Word64
deinterleaveBits :: Exp Word64 -> Exp (Word32, Word32)

-- | Returns a single 64-bit number where all even-indexed bits are set to
--   the bits of <tt>a</tt>.
--   
--   So the MSB is 0, the next bit is the MSB of <tt>a</tt>, the next is 0,
--   the next is next-highest bit of <tt>a</tt> etc.
--   
--   Kudos to
--   <a>https://lemire.me/blog/2018/01/08/how-fast-can-you-bit-interleave-32-bit-integers/</a>
--   for explaining this bit-twiddling technique in detail.
expandBits :: Exp Word32 -> Exp Word64
shrinkBits :: Exp Word64 -> Exp Word32


-- | Contains common types, type aliases and functions that are used
--   throughout the application
module Lib.Common

-- | Since we are working in 2D, a point contaisn two coordinates.
type Point = (Float, Float)

-- | A point that we can easily transform using our <tt>Transformation</tt>
--   type.
type HomogeneousPoint = V3 Float

-- | Turns a 2D (x, y) point into a 3D vector ('homogeneous notation')
--   where the <tt>z</tt> component is 1
pointToHomogeneous :: Point -> HomogeneousPoint

-- | Identical to <a>pointToHomogeneous</a> but runs on the GPU
pointToHomogeneousGPU :: Exp Point -> Exp HomogeneousPoint

-- | Inverse of <a>pointToHomogeneous</a>
--   
--   Note that <tt>s</tt> is not always `1`; it is altered by scaling
--   transformations.
homogeneousToPoint :: HomogeneousPoint -> Point

-- | Identical to <a>homogeneousToPoint</a> but runs on the GPU
homogeneousToPointGPU :: Exp HomogeneousPoint -> Exp Point

-- | Runs a function working on a point in homogeneous form on a
--   <tt>normal</tt> 2D point. by wrapping it in a conversion to and from
--   homogeneous notation
mapPointAsHomogeneous :: (HomogeneousPoint -> HomogeneousPoint) -> Point -> Point

-- | Identical to <a>mapPointAsHomogeneous</a> but runs on the GPU
mapPointAsHomogeneousGPU :: (Exp HomogeneousPoint -> Exp HomogeneousPoint) -> Exp Point -> Exp Point


-- | Hides the implementation details of transformations. To the outside
--   world they are opaque, and only the operations we require are exported
--   from this module.
--   
--   Secretly they are 3x3 matrices.
module Lib.Transformation

-- | An affine transformation is manipulated in this program as its
--   augmented matrix.
type Transformation = M33 Float

-- | Type that indicates that we are expecting a float in the [0..1) range.
type Probability = Float

-- | An Iterated Function System is described by a collection of
--   transformations with, for the Chaos Game, associated probabilities
type IFS = Vector (Transformation, Probability)
fromSixtuplePair :: ((Float, Float, Float, Float, Float, Float), Probability) -> (Transformation, Probability)
fromSixtuplePairGPU :: Exp ((Float, Float, Float, Float, Float, Float), Probability) -> Exp (Transformation, Probability)
fromSixtuple :: (Float, Float, Float, Float, Float, Float) -> Transformation
fromSixtupleGPU :: Exp (Float, Float, Float, Float, Float, Float) -> Exp Transformation
identity :: Transformation
isInvertible :: Transformation -> Bool
transform :: Transformation -> Point -> Point

-- | Transforms a point from world space to screen space. (Runs on the
--   GPU!)
transformGPU :: Exp Transformation -> Exp Point -> Exp Point
invert :: Transformation -> Maybe Transformation
combine :: [Transformation] -> Transformation

module Lib.Geometry

-- | Tests if <tt>inner</tt> is fully contained inside <tt>outer</tt>.
isPolygonInsidePolygon :: Polygon -> Polygon -> Bool

-- | Tests whether a single 2D point is inside a (concave) polygon
--   
--   Haskell implementation of the algorithm known as 'even-odd rule'
--   algorithm or 'crossing number' algorithm described in detail at
--   <a>https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html</a>
--   
--   ## Examples:
--   
--   <pre>
--   &gt;&gt;&gt; let rect = [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)]
--   
--   &gt;&gt;&gt; isPointInsidePolygon rect (0.5, 0.5)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let rect = [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)]
--   
--   &gt;&gt;&gt; isPointInsidePolygon rect (1.5, 0.5)
--   False
--   </pre>
isPointInsidePolygon :: Polygon -> Point -> Bool


-- | transformations to (groups of) points to turn them from world-space to
--   screen-space.
--   
--   The camera (a transformation matrix) itself is meant to be manipulated
--   on the CPU. The resulting transformation is then given to the GPU to
--   map over all (visible) points.
module Lib.Camera

-- | A camera is <tt>just</tt> another transformation
type Camera = Transformation

-- | Scales the camera in equal proportions using the given <a>scale</a>
--   float.
--   
--   Scales to the middle of the screen.
scale :: Float -> Camera -> Camera

-- | Translates the camera position using the given <tt>horizontal</tt> and
--   <tt>vertical</tt> offsets.
translate :: Float -> Float -> Camera -> Camera
fromSixtuple :: (Float, Float, Float, Float, Float, Float) -> Camera

-- | Transforms a point from world space to screen space.
cameraTransform :: Camera -> Point -> Point

-- | Transforms a point from world space to screen space. (Runs on the
--   GPU!)
cameraTransformGPU :: Exp Camera -> Exp Point -> Exp Point

-- | Inverts the transformation the camera makes. useful for e.g. checking
--   where the picure bounds (screen space) end up in world space.
inverse :: Camera -> Camera
withInitial :: Camera -> Camera -> Camera
identity :: Transformation


-- | Transforming a point cloud to a rasterized picture, using a camera
--   transformation.
module Lib.Picture
type RasterPicture = Matrix Word32

-- | A very simple way to create a picture from a point cloud. No
--   optimizations: we iterate over all points and only find out very late
--   whether they'll end up on the screen.
naivePointCloudToPicture :: Exp Camera -> Exp Int -> Exp Int -> Acc (Vector Point) -> Acc RasterPicture


-- | Main entry-point of the `domain model' part of the application. This
--   module re-exports some of the nested module's types so that we can
--   e.g. write `Lib.Camera === Lib.Camera.Camera`
module Lib
naivePointCloudToPicture :: Acc (Scalar Camera) -> Acc (Scalar Int) -> Acc (Scalar Int) -> Acc (Vector Point) -> Acc RasterPicture

-- | A camera is <tt>just</tt> another transformation
type Camera = Transformation
type RasterPicture = Matrix Word32

-- | An affine transformation is manipulated in this program as its
--   augmented matrix.
type Transformation = M33 Float

-- | An Iterated Function System is described by a collection of
--   transformations with, for the Chaos Game, associated probabilities
type IFS = Vector (Transformation, Probability)


-- | Module to render <tt>guide≈õ</tt>. These are four-point polygons which
--   indicate (rough estimates of) regions in which all points have had a
--   particular transformation applied to them.
module Lib.Guide
drawGuides :: Camera -> Camera -> (Word, Word) -> [Transformation] -> Picture

-- | Returns all combinations of the elements in a list This goes on
--   forever. Shorter combinations are first
--   
--   ## Examples:
--   
--   <pre>
--   &gt;&gt;&gt; take 4 $ allCombinations [1, 2, 3]
--   [[],[1],[2],[3]]
--   
--   &gt;&gt;&gt; take 13 $ allCombinations [1, 2, 3]
--   [[],[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
--   </pre>
allCombinations :: [a] -> [[a]]

-- | Returns all combinations of the elements in a list that are at most
--   <tt>depth</tt> elements long Shorter combinations are returned first.
--   
--   ## Examples:
--   
--   <pre>
--   &gt;&gt;&gt; combinationsUpToDepth 0 [1, 2, 3]
--   [[]]
--   
--   &gt;&gt;&gt; combinationsUpToDepth 1 [1, 2, 3]
--   [[],[1],[2],[3]]
--   
--   &gt;&gt;&gt; combinationsUpToDepth 2 [1, 2, 3]
--   [[],[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
--   </pre>
combinationsUpToDepth :: Int -> [a] -> [[a]]

-- | Checks whether the current camera is <tt>inside</tt> a transformation
--   
--   Here <tt>inside</tt> means that the <tt>screen</tt> transformed by the
--   inverse camera matrix, is completely contained in the <tt>screen</tt>
--   transformed by the transformation.
--   
--   <tt>initial_camera</tt> is used to move between 'normalized screen
--   coordinates' (which <tt>camera</tt> uses) and 'world coordinates'
--   (which <tt>transformation</tt> uses).
isCameraInsideTransformation :: Camera -> Camera -> Transformation -> Bool


-- | Contains small functions that are used in multiple places.
module Helper
bitsList :: [Int]

-- | Returns a single 64-bit number where all even-indexed bits are set to
--   the bits of <tt>a</tt>.
--   
--   So the MSB is 0, the next bit is the MSB of <tt>a</tt>, the next is 0,
--   the next is next-highest bit of <tt>a</tt> etc.
--   
--   Kudos to
--   <a>https://lemire.me/blog/2018/01/08/how-fast-can-you-bit-interleave-32-bit-integers/</a>
--   for explaining this bit-twiddling technique in detail.
expandBits :: Word32 -> Word64

-- | Returns the morton-code interleaving
--   
--   where from MSB to LSB we have one bit of y and then of x (and then the
--   next-highest bit of y and then the next-highest bit of x etc).
interleaveBits :: Word32 -> Word32 -> Word64
shrinkBits :: Word64 -> Word32
deinterleaveBits :: Word64 -> (Word32, Word32)


-- | This module deals with the sorting of data in parallel on the GPU.
--   
--   The main entrypoint is <a>sortPoints</a>. The other exposed functions
--   are building blocks of that one. They are exposed to be easily
--   testable themselves.
module Lib.Sort

-- | Sorts an array of points by the Z-order curve (AKA morton code)
--   
--   This is done by transforming the pair of 32-bit floats to 32-bit
--   unsigned int, and combining them to get one unsigned 64-bit int. After
--   sorting, this transformation is reversed.
sortPoints :: Acc (Vector (Float, Float)) -> Acc (Vector (Float, Float))

-- | A full parallel Radix Sort
--   
--   ## Implementation notes:
--   
--   This implementation uses 64 unrolled implementations of
--   <a>radixSortBit</a>, one for each bit in a 64-bit number.
--   
--   The nice thing about using Accelerate is that we can manipulate the
--   AST creation using techniques like this one where we can create an
--   unrolled version of something that would be horrible to write by hand.
--   
--   ## Examples
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Array.Accelerate.LLVM.Native as CPU
--   
--   &gt;&gt;&gt; arr = use $ fromList (Z :. 10) ([10, 9..]) :: Acc (Vector Word64)
--   
--   &gt;&gt;&gt; CPU.run $ Lib.Sort.radixSort arr
--   Vector (Z :. 10) [1,2,3,4,5,6,7,8,9,10]
--   </pre>
radixSort :: Acc (Vector Word64) -> Acc (Vector Word64)

-- | One step of parallel radix sort, for a single bit.
radixSortBit :: Int -> Acc (Vector Word64) -> Acc (Vector Word64)


-- | Generate random data in parallel on the GPU, based on a single seed.
--   
--   We use the <tt>xorShift</tt> method to generate data. This is not a
--   very high-quality generator, but it should be good enough for our
--   purposes.
module Lib.Random

-- | Fills a vector of <a>length</a> length with random numbers using
--   <tt>seed</tt> as starting seed.
randomVector :: Int -> Word64 -> Acc (Vector Word64)

-- | A cute implementation of a <tt>random</tt> matrix.
--   
--   However, since we do not fully split the RNG, some entries to the
--   top-left of the matrix might be close to each-other.
--   
--   If better RNG is needed, we might be able to use something like the
--   <tt>jump</tt> mentioned on <a>http://prng.di.unimi.it/</a>
randomMatrix :: Int -> Int -> Word64 -> Acc (Matrix Word64)

-- | Simple XorShift Random Number Generator Returns a new number based on
--   the given one. Note that XorShift is an _ok_ RNG but not a very
--   high-quality one: Specifically, it will fail certain statistical
--   tests. Also, it will never return `0` (if given any number except
--   `0`).
xorShift64 :: Exp Word64 -> Exp Word64

-- | Returns a double in the half-open range [0, 1) based on the random
--   unsigned integer that was generated.
--   
--   This uses the notes at <a>http://prng.di.unimi.it/</a>. Specifically:
--   A double has a significant binary digits 53. We extract thus the top
--   53 bits of the number (which are better quality than the lower 11) We
--   multiply this by `0x1.0p-53` (that is: 1.0 * 2^-53) to obtain a number
--   in the half-open interval [0, 1)
extractRandomUnitIntervalDouble :: Exp Word64 -> Exp Double


-- | Parallel 'Chaos Game' implementation. The Chaos Game is a
--   probabilistic algorithm to draw an Iterated Function System.
--   Curiously, given enough points, the contraction of the IFS will ensure
--   that the result will converge to the same deterministic picture.
--   
--   This implementation of the Chaos Game takes a description of an IFS as
--   input, performs all random number generation and point-transforming on
--   the GPU itself, and finally returns a single vector of points as
--   output.
--   
--   This vector might be kept on the GPU for further manipulation (e.g.
--   drawing pictures from them) afterwards.
--   
--   Note that many <tt>internal</tt> functions of this module have also
--   been exported, to make testing the various components easier.
module Lib.ChaosGame

-- | Runs the chaos game
--   
--   Note that this implementation runs on a two-dimensional matrix: each
--   row is handled by a different thread each field in each row is the
--   next iteration of the chaos game.
--   
--   Essentially this means that for a high number of
--   <tt>n_points_per_thread</tt> we'll have very high-quality points.
--   whereas for a high <tt>paralellism</tt> we'll be able to run the
--   chaosGame faster.
--   
--   So depending on the particular IFS and GPU, you'll want to tune those
--   values differently.
chaosGame :: Acc IFS -> Int -> Int -> Acc (Matrix Word64) -> Acc (Vector Point)

-- | Given a matrix with random points we will perform the 'chaos game',
--   separately on each row. So all points in column `0` will be initial
--   points, in column `1` will have one transformation applied, in column
--   `2` two transformations, etc.
fillChaosGameMatrix :: Acc IFS -> Acc (Matrix Point) -> Acc (Matrix Point)

-- | A fast way to turn a (Float, Float) into a Word64.
--   
--   The hope is that LLVM or the PTX compilers might optimize it to a
--   no-op, if the pair is adjacent in memory. Do not confuse this with
--   <tt>pointToMorton</tt>.
floatPairToWord64 :: Exp Point -> Exp Word64

-- | Inverse of <a>floatPairToWord64</a>
word64ToFloatPair :: Exp Word64 -> Exp Point
