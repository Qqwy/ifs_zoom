-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Feature-complete microlens
--   
--   This package exports a module which is the recommended starting point
--   for using <a>microlens</a> if you aren't trying to keep your
--   dependencies minimal. By importing <tt>Lens.Micro.Platform</tt> you
--   get all functions and instances from <a>microlens</a>,
--   <a>microlens-th</a>, <a>microlens-mtl</a>, <a>microlens-ghc</a>, as
--   well as instances for <tt>Vector</tt>, <tt>Text</tt>, and
--   <tt>HashMap</tt>.
--   
--   The minor and major versions of microlens-platform are incremented
--   whenever the minor and major versions of any other microlens package
--   are incremented, so you can depend on the exact version of
--   microlens-platform without specifying the version of microlens
--   (microlens-mtl, etc) you need.
--   
--   This package is a part of the <a>microlens</a> family; see the readme
--   <a>on Github</a>.
@package microlens-platform
@version 0.3.11


module Lens.Micro.Platform.Internal
class IsText t

-- | <a>packed</a> lets you convert between <a>String</a> and <tt>Text</tt>
--   (strict or lazy). It can be used as a replacement for <tt>pack</tt> or
--   as a way to modify some <a>String</a> if you have a function like
--   <tt>Text -&gt; Text</tt>.
packed :: IsText t => Lens' String t

-- | <a>unpacked</a> is like <a>packed</a> but works in the opposite
--   direction.
unpacked :: IsText t => Lens' t String
instance Lens.Micro.Platform.Internal.IsText GHC.Base.String
instance Lens.Micro.Platform.Internal.IsText Data.Text.Internal.Text
instance Lens.Micro.Platform.Internal.IsText Data.Text.Internal.Lazy.Text


-- | This module is an approximation for <tt><a>Control.Lens</a></tt> from
--   <a>lens</a>; by importing it you get all functions and instances from
--   <a>microlens</a>, <a>microlens-mtl</a>, <a>microlens-ghc</a>, as well
--   as the following instances:
--   
--   <ul>
--   <li><a>at</a> for <a>HashMap</a></li>
--   <li><a>each</a> and <a>ix</a>
--   for<ul><li><a>HashMap</a></li><li><a>Vector</a> and variants (unboxed
--   vectors, etc)</li><li>strict <a>Text</a> and lazy
--   <a>Text</a></li></ul></li>
--   <li><a>_head</a>, <a>_tail</a>, <a>_init</a>, <a>_last</a>
--   for<ul><li><a>Vector</a> and variants</li><li>strict and lazy
--   <tt>Text</tt></li></ul></li>
--   <li><a>strict</a> and <a>lazy</a> for <tt>Text</tt></li>
--   </ul>
module Lens.Micro.Platform

-- | <a>packed</a> lets you convert between <a>String</a> and <tt>Text</tt>
--   (strict or lazy). It can be used as a replacement for <tt>pack</tt> or
--   as a way to modify some <a>String</a> if you have a function like
--   <tt>Text -&gt; Text</tt>.
packed :: IsText t => Lens' String t

-- | <a>unpacked</a> is like <a>packed</a> but works in the opposite
--   direction.
unpacked :: IsText t => Lens' t String
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Lens.Micro.Internal.Ixed (Data.HashMap.Base.HashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Lens.Micro.Internal.At (Data.HashMap.Base.HashMap k a)
instance Lens.Micro.Internal.Ixed (Data.Vector.Vector a)
instance Data.Primitive.Types.Prim a => Lens.Micro.Internal.Ixed (Data.Vector.Primitive.Vector a)
instance Foreign.Storable.Storable a => Lens.Micro.Internal.Ixed (Data.Vector.Storable.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Lens.Micro.Internal.Ixed (Data.Vector.Unboxed.Base.Vector a)
instance Lens.Micro.Internal.Ixed Data.Text.Internal.Text
instance Lens.Micro.Internal.Ixed Data.Text.Internal.Lazy.Text
instance Lens.Micro.Internal.Cons Data.Text.Internal.Text Data.Text.Internal.Text GHC.Types.Char GHC.Types.Char
instance Lens.Micro.Internal.Cons Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text GHC.Types.Char GHC.Types.Char
instance Lens.Micro.Internal.Snoc Data.Text.Internal.Text Data.Text.Internal.Text GHC.Types.Char GHC.Types.Char
instance Lens.Micro.Internal.Snoc Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text GHC.Types.Char GHC.Types.Char
instance Lens.Micro.Internal.Cons (Data.Vector.Vector a) (Data.Vector.Vector b) a b
instance (Data.Primitive.Types.Prim a, Data.Primitive.Types.Prim b) => Lens.Micro.Internal.Cons (Data.Vector.Primitive.Vector a) (Data.Vector.Primitive.Vector b) a b
instance (Foreign.Storable.Storable a, Foreign.Storable.Storable b) => Lens.Micro.Internal.Cons (Data.Vector.Storable.Vector a) (Data.Vector.Storable.Vector b) a b
instance (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Lens.Micro.Internal.Cons (Data.Vector.Unboxed.Base.Vector a) (Data.Vector.Unboxed.Base.Vector b) a b
instance Lens.Micro.Internal.Snoc (Data.Vector.Vector a) (Data.Vector.Vector b) a b
instance (Data.Primitive.Types.Prim a, Data.Primitive.Types.Prim b) => Lens.Micro.Internal.Snoc (Data.Vector.Primitive.Vector a) (Data.Vector.Primitive.Vector b) a b
instance (Foreign.Storable.Storable a, Foreign.Storable.Storable b) => Lens.Micro.Internal.Snoc (Data.Vector.Storable.Vector a) (Data.Vector.Storable.Vector b) a b
instance (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Lens.Micro.Internal.Snoc (Data.Vector.Unboxed.Base.Vector a) (Data.Vector.Unboxed.Base.Vector b) a b
instance Lens.Micro.Internal.Each (Data.Vector.Vector a) (Data.Vector.Vector b) a b
instance (Data.Primitive.Types.Prim a, Data.Primitive.Types.Prim b) => Lens.Micro.Internal.Each (Data.Vector.Primitive.Vector a) (Data.Vector.Primitive.Vector b) a b
instance (Foreign.Storable.Storable a, Foreign.Storable.Storable b) => Lens.Micro.Internal.Each (Data.Vector.Storable.Vector a) (Data.Vector.Storable.Vector b) a b
instance (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Lens.Micro.Internal.Each (Data.Vector.Unboxed.Base.Vector a) (Data.Vector.Unboxed.Base.Vector b) a b
instance (c Data.Type.Equality.~ d) => Lens.Micro.Internal.Each (Data.HashMap.Base.HashMap c a) (Data.HashMap.Base.HashMap d b) a b
instance (a Data.Type.Equality.~ GHC.Types.Char, b Data.Type.Equality.~ GHC.Types.Char) => Lens.Micro.Internal.Each Data.Text.Internal.Text Data.Text.Internal.Text a b
instance (a Data.Type.Equality.~ GHC.Types.Char, b Data.Type.Equality.~ GHC.Types.Char) => Lens.Micro.Internal.Each Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text a b
instance Lens.Micro.Internal.Strict Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
