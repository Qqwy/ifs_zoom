-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | microlens + array, bytestring, containers, transformers
--   
--   Use this package instead of <a>microlens</a> if you don't mind
--   depending on all dependencies here â€“ <tt>Lens.Micro.GHC</tt> reexports
--   everything from <tt>Lens.Micro</tt> and additionally provides orphan
--   instances of microlens classes for packages coming with GHC
--   (<a>array</a>, <a>bytestring</a>, <a>containers</a>,
--   <a>transformers</a>).
--   
--   The minor and major versions of microlens-ghc are incremented whenever
--   the minor and major versions of microlens are incremented, so you can
--   depend on the exact version of microlens-ghc without specifying the
--   version of microlens you need.
--   
--   This package is a part of the <a>microlens</a> family; see the readme
--   <a>on Github</a>.
@package microlens-ghc
@version 0.4.10


module Lens.Micro.GHC.Internal
class IsByteString t

-- | Treat a list of bytes as a strict or lazy <tt>ByteString</tt>.
packedBytes :: IsByteString t => Lens' [Word8] t

-- | Treat a strict or lazy <tt>ByteString</tt> as a list of bytes.
unpackedBytes :: IsByteString t => Lens' t [Word8]

-- | Treat a <a>String</a> as a strict or lazy <tt>ByteString</tt>. (Note
--   that it will garble characters above 0xFF, same as <a>pack</a> does.)
packedChars :: IsByteString t => Lens' String t

-- | Treat a strict or lazy <tt>ByteString</tt> as a <a>String</a>. (Just
--   as <a>packedChars</a>, it will garble characters above 0xFF.)
unpackedChars :: IsByteString t => Lens' t String

-- | Traverse characters in a strict or lazy <tt>ByteString</tt> (to
--   traverse bytes instead of characters, use <a>each</a>).
chars :: IsByteString t => Traversal' t Char
unpackStrict :: ByteString -> [Word8]
unpackStrict8 :: ByteString -> String
unpackLazy :: ByteString -> [Word8]
unpackLazy8 :: ByteString -> String
fromStrict :: ByteString -> ByteString
toStrict :: ByteString -> ByteString
traversedStrictTree :: Traversal' ByteString Word8
traversedStrictTree8 :: Traversal' ByteString Char
traversedLazy :: Traversal' ByteString Word8
traversedLazy8 :: Traversal' ByteString Char
instance Lens.Micro.GHC.Internal.IsByteString Data.ByteString.Internal.ByteString
instance Lens.Micro.GHC.Internal.IsByteString Data.ByteString.Lazy.Internal.ByteString


-- | By importing this module you get all functions and types from
--   <a>microlens</a>, as well as the following instances:
--   
--   <ul>
--   <li><a>at</a> for <a>Map</a> and <a>IntMap</a></li>
--   <li><a>each</a> and <a>ix</a> for<ul><li><a>Map</a> and
--   <a>IntMap</a></li><li><a>Array</a> and
--   <a>UArray</a></li><li><a>Seq</a></li><li>strict <a>ByteString</a> and
--   lazy <a>ByteString</a></li><li><a>Tree</a></li></ul></li>
--   <li><a>_head</a>, <a>_tail</a>, <a>_init</a>, <a>_last</a>
--   for<ul><li><a>Seq</a></li><li>strict and lazy
--   bytestrings</li></ul></li>
--   <li><a>strict</a> and <a>lazy</a>
--   for<ul><li>bytestrings</li><li><tt>StateT</tt>, <tt>WriterT</tt>,
--   <tt>RWST</tt></li></ul></li>
--   </ul>
module Lens.Micro.GHC

-- | Treat a list of bytes as a strict or lazy <tt>ByteString</tt>.
packedBytes :: IsByteString t => Lens' [Word8] t

-- | Treat a strict or lazy <tt>ByteString</tt> as a list of bytes.
unpackedBytes :: IsByteString t => Lens' t [Word8]

-- | Treat a <a>String</a> as a strict or lazy <tt>ByteString</tt>. (Note
--   that it will garble characters above 0xFF, same as <a>pack</a> does.)
packedChars :: IsByteString t => Lens' String t

-- | Treat a strict or lazy <tt>ByteString</tt> as a <a>String</a>. (Just
--   as <a>packedChars</a>, it will garble characters above 0xFF.)
unpackedChars :: IsByteString t => Lens' t String

-- | Traverse characters in a strict or lazy <tt>ByteString</tt> (to
--   traverse bytes instead of characters, use <a>each</a>).
chars :: IsByteString t => Traversal' t Char
instance GHC.Classes.Ord k => Lens.Micro.Internal.Ixed (Data.Map.Internal.Map k a)
instance Lens.Micro.Internal.Ixed (Data.IntMap.Internal.IntMap a)
instance Lens.Micro.Internal.Ixed (Data.Sequence.Internal.Seq a)
instance Lens.Micro.Internal.Ixed (Data.Tree.Tree a)
instance GHC.Arr.Ix i => Lens.Micro.Internal.Ixed (GHC.Arr.Array i e)
instance (Data.Array.Base.IArray Data.Array.Base.UArray e, GHC.Arr.Ix i) => Lens.Micro.Internal.Ixed (Data.Array.Base.UArray i e)
instance Lens.Micro.Internal.Ixed Data.ByteString.Internal.ByteString
instance Lens.Micro.Internal.Ixed Data.ByteString.Lazy.Internal.ByteString
instance Lens.Micro.Internal.At (Data.IntMap.Internal.IntMap a)
instance GHC.Classes.Ord k => Lens.Micro.Internal.At (Data.Map.Internal.Map k a)
instance (c Data.Type.Equality.~ d) => Lens.Micro.Internal.Each (Data.Map.Internal.Map c a) (Data.Map.Internal.Map d b) a b
instance Lens.Micro.Internal.Each (Data.IntMap.Internal.IntMap a) (Data.IntMap.Internal.IntMap b) a b
instance Lens.Micro.Internal.Each (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Lens.Micro.Internal.Each (Data.Tree.Tree a) (Data.Tree.Tree b) a b
instance (GHC.Arr.Ix i, i Data.Type.Equality.~ j) => Lens.Micro.Internal.Each (GHC.Arr.Array i a) (GHC.Arr.Array j b) a b
instance (GHC.Arr.Ix i, Data.Array.Base.IArray Data.Array.Base.UArray a, Data.Array.Base.IArray Data.Array.Base.UArray b, i Data.Type.Equality.~ j) => Lens.Micro.Internal.Each (Data.Array.Base.UArray i a) (Data.Array.Base.UArray j b) a b
instance (a Data.Type.Equality.~ GHC.Word.Word8, b Data.Type.Equality.~ GHC.Word.Word8) => Lens.Micro.Internal.Each Data.ByteString.Internal.ByteString Data.ByteString.Internal.ByteString a b
instance (a Data.Type.Equality.~ GHC.Word.Word8, b Data.Type.Equality.~ GHC.Word.Word8) => Lens.Micro.Internal.Each Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString a b
instance Lens.Micro.Internal.Cons (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Lens.Micro.Internal.Snoc (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Lens.Micro.Internal.Cons Data.ByteString.Internal.ByteString Data.ByteString.Internal.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Lens.Micro.Internal.Cons Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Lens.Micro.Internal.Snoc Data.ByteString.Internal.ByteString Data.ByteString.Internal.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Lens.Micro.Internal.Snoc Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Lens.Micro.Internal.Strict Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Internal.ByteString
instance Lens.Micro.Internal.Strict (Control.Monad.Trans.State.Lazy.StateT s m a) (Control.Monad.Trans.State.Strict.StateT s m a)
instance Lens.Micro.Internal.Strict (Control.Monad.Trans.Writer.Lazy.WriterT w m a) (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance Lens.Micro.Internal.Strict (Control.Monad.Trans.RWS.Lazy.RWST r w s m a) (Control.Monad.Trans.RWS.Strict.RWST r w s m a)
